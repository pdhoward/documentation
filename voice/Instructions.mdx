## VOX: Voice Agent Builder ‚Äî Instructions

### A Voice For Every Business

<Callout title="Introduction">
  This guide helps you create a custom voice agent for your business. Voice agents act as intelligent concierges, sales reps, or assistants‚Äîhandling queries, accessing data, and performing actions like bookings or product searches. You'll define tools, connect to your data via APIs, and craft prompts to guide the agent's behavior.
</Callout>

**Assumptions**:
- Core tools (e.g., time checks, website scraping) are auto-provided by the platform.
- Use the JSON Editor tool to create/edit tool descriptors and prompts.
- Use the MongoDB Updater tool to store configurations in your tenant's database.
- Test directly by starting the agent or using provided test scripts.

<StepCard title="Understand Core Tools" description="These utility tools are available to every agent. Use them to enhance interactions without custom setup. Review the table below to see how they fit your use case.">
  Core tools are pre-defined and fed into the agent's schema automatically. They handle common tasks like fetching time, scraping websites, or rendering visuals. You don't need to define them, but reference them in your prompt for the agent to use them.

  **Tip**: The `scrapeWebsite` tool is powerful for dynamic data‚Äîe.g., a sales agent scraping recent product announcements from your site. For visuals, use `show_component` to display media fetched from your APIs.

  To integrate: Reference these in your prompt's "capabilities.tools" section (see Step 4).
</StepCard>

<StepCard title="Core Tools" description="Quick reference for built-in utilities.">
  Use these without extra setup. For visuals, prefer `show_component`.
</StepCard>

| Tool Name             | Description                                                                 | When to Use (Examples)                                                                 | Parameters |
|-----------------------|-----------------------------------------------------------------------------|----------------------------------------------------------------------------------------|------------|
| getCurrentTime        | Returns the current local time and timezone.                                | User asks "What time is it?" or needs time-based info.                                | None       |
| changeBackgroundColor | Toggles between light and dark UI themes.                                   | User says "Switch to dark mode" for accessibility or fun.                             | None       |
| partyMode             | Triggers confetti and animations for celebration.                           | User says "Celebrate!" after a successful booking or purchase.                        | None       |
| launchWebsite         | Opens a URL in a new browser tab.                                           | User asks "Open example.com" or to view external resources.                           | `url` (string, http/https) |
| copyToClipboard       | Copies text to the user's clipboard.                                        | User needs to copy a code, ID, or confirmation.                                       | `text` (string) |
| scrapeWebsite         | Fetches and returns website content as markdown/HTML for summarization.     | User asks to summarize a public site, e.g., "Scrape data.gov and tell me what's new." | `url` (string, http/https) |
| show_component        | Renders UI components like images, videos, payments, or catalogs.           | Display visuals, e.g., product images or a payment form. Supported components: payment_form, quote_summary, catalog_results, reservation_confirmation, room, video, image_viewer, media_gallery. | `component_name` (required), `title`, `description`, `size` (sm/md/lg/xl), `url`, `media` (array of image/video objects), `props` (object) |

---

<StepCard title="Define Custom Tools" description="Build HTTP-based tools to connect the agent to your APIs and databases. These allow actions like querying inventory, creating bookings, or searching products.">
  Custom tools are defined as JSON descriptors using the HTTP Tool Schema. They specify API endpoints, parameters, and behaviors.
</StepCard>

1. **Open the JSON Editor**: Use the JSON Editor tool to create a new descriptor file (e.g., `my-tools.json`).

2. **Define the Schema**: Each tool follows this structure (based on Zod schema for validation):

```json
{
  "kind": "http_tool",
  "name": "your_tool_name",
  "description": "Brief tool purpose",
  "parameters": {
    "type": "object",
    "properties": {
      "param1": { "type": "string" }
    },
    "required": ["param1"]
  },
  "http": {
    "method": "GET|POST|PUT|PATCH|DELETE",
    "urlTemplate": "https://your-api.com/endpoint/&#123;&#123;param1&#125;&#125;",
    "headers": { "authorization": "Bearer &#123;&#123;secrets.api_key&#125;&#125;" },
    "jsonBodyTemplate": { "key": "&#123;&#123;param1&#125;&#125;" },
    "okField": "ok",
    "timeoutMs": 8000,
    "pruneEmpty": true
  },
  "ui": {
    "onSuccess": {
      "open": {
        "component_name": "catalog_results",
        "title": "Results",
        "props": { "items": "&#123;&#123;response.items&#125;&#125;" }
      }
    },
    "onError": { /* Similar structure */ }
  },
  "enabled": true,
  "priority": 5,
  "version": 1
}

```

  3. **Examples**:
     - **Booking a Room** (from Cypress Resort):
       ```json
       {
         "name": "booking_reserve",
         "description": "Create a reservation for a unit between dates.",
         "parameters": {
           "type": "object",
           "required": ["tenant_id", "unit_id", "check_in", "check_out", "guest"],
           "properties": {
             "tenant_id": { "type": "string" },
             "unit_id": { "type": "string" },
             "check_in": { "type": "string", "pattern": "^\\d{4}-\\d{2}-\\d{2}$" },
             "check_out": { "type": "string", "pattern": "^\\d{4}-\\d{2}-\\d{2}$" },
             "guest": { /* Object with name, email, etc. */ }
           }
         },
         "http": {
           "method": "POST",
           "urlTemplate": "https://your-booking-api.com/api/booking/&#123;&#123;tenant_id&#125;&#125;/reserve",
           "jsonBodyTemplate": { /* Map params to body */ }
         }
       }
       ```
     - **Searching Products** (Generalized for e-commerce):
       ```json
       {
         "name": "search_products",
         "description": "Search inventory for products matching a query.",
         "parameters": {
           "type": "object",
           "required": ["query"],
           "properties": {
             "query": { "type": "string" },
             "limit": { "type": "number", "default": 10 }
           }
         },
         "http": {
           "method": "GET",
           "urlTemplate": "https://your-store-api.com/products?q=&#123;&#123;query&#125;&#125;&limit=&#123;&#123;limit&#125;&#125;"
         },
         "ui": {
           "onSuccess": {
             "open": {
               "component_name": "catalog_results",
               "props": { "items": "&#123;&#123;response.products&#125;&#125;" }
             }
           }
         }
       }
       ```
     - **MongoDB Query** (for custom data fetches):
       ```json
       {
         "name": "list_things_via_gateway",
         "description": "Browse catalog items (e.g., products, events).",
         "parameters": {
           "type": "object",
           "required": ["tenant_id"],
           "properties": {
             "tenant_id": { "type": "string" },
             "type": { "type": "string" },
             "q": { "type": "string" }
           }
         },
         "http": {
           "method": "POST",
           "urlTemplate": "/api/mongo/gateway",
           "jsonBodyTemplate": { "op": "find", "filter": { /* Mongo query */ } }
         }
       }
       ```


// HTTP tool descriptors with declarative UI instructions.
// Runtime behavior (from /api/tools/execute):
//  - Templating context is { args, response, status, secrets }.
//  - Strings in url/headers/body/ui are templated via `tpl()` (supports filters).
//  - Success = http.okField exists (truthy) in response OR HTTP 2xx when okField omitted.
//  - Then apply ui.onSuccess or ui.onError; payload is templated again with the same ctx.
//  - `pruneEmpty: true` strips "", null, {}, [] before sending.
//
// ‚úÖ Authoring rules (critical):
//  1) Always reference caller params as {{args.your_field}} (not just {{your_field}}).
//  2) Coerce numbers/booleans in templates using filters, e.g. {{args.limit | number}}, {{args.include_rates | bool}}.
//  3) For currency, prefer {{args.currency | default('USD') | upper}}.
//  4) For nested JSON props, pass structured objects (not stringified), e.g. customer: "{{args.prefill | json}}".
//  5) Keep okField aligned with the API‚Äôs success shape (e.g., "ok" or "clientSecret").
//  6) If your API needs auth, use {{secrets.*}} in headers; the server will inject the secret.
 
 Validation of Data Against SchemaI validated the provided tool descriptors (the actions array) against the Zod schema (HttpToolDescriptorSchema). All 6 tools parse successfully without errors, meaning they are structurally consistent and compatible with the schema. Here's a summary:Key Compatibilities:All tools have required fields like kind: "http_tool", name, http.method, http.urlTemplate.
parameters match the permissive JSON Schema-ish structure (object with type, required, properties, etc.).
http configs are valid (methods are correct enums, timeouts are positive integers ‚â§120000, etc.).
ui sections (where present) match HttpUISchema: component_name is string, size is valid enum, props are JSON-like.
Optional fields like description, priority, version, enabled are handled correctly.
Nested structures (e.g., guest and payment in booking_reserve) validate per their schemas (types, patterns, enums, min/max).

Minor Notes (Not Errors):Some tools use pattern in parameters (e.g., date regex), which is allowed as the schema is permissive.
jsonBodyTemplate can be complex objects with templates, which parses fine as JsonValue.
No invalid enums or types found.
The schema defaults kind to "http_tool" and enabled to true, which aligns with the data.

If you add new tools in the future, this schema will enforce consistency. The data represents a solid "standard" for well-formed descriptors.


  4. **Save and Upload**: Use the MongoDB Updater tool to store the descriptors under your tenantId (e.g., collection: "tools").

  **Tip**: Tools auto-populate the agent's decision-making. Ensure your APIs return structured JSON (e.g., `{ ok: true, data: {...} }`) for easy handling.

<StepCard title="Connect to Your Data" description="Expose data via APIs that tools can call. The agent uses returned objects to inform responses‚Äîe.g., describing products or checking availability.">
  Your APIs provide the "data grounding" for the agent. Design them to return rich JSON objects.

RATE LIMITS: Why both IP and user?

One user can abuse from many IPs (mobile, VPN, cloud).
One IP (office, campus, caf√©) can have many legit users.
Combine both: block obvious floods at the IP layer (Edge), then apply precise user limits/quota (Server). This is the industry pattern (rate limit template + middleware).


### voice consideration Notes
I‚Äôm building an app that uses realtime voice interactions and the biggest bottleneck right now is the speed of response of OpenAI TTS

I need it blazing fast

- This is still a big engineering problem for all companies offering realtime or near realtime low latency STT and TTS, don't expect much difference from any provider.. but maybe with some buffering techniques you can lower the impact a bit?

> eleven labs 

> Depending on your setup, you can consider using a combination of nano models with lightweight STT/TTS libraries. PocketTTS is very small and extremely fast, Vogent‚Äôs turn keeping is also lightweight and responsive and if you‚Äôre not locked in to OpenAI, Gemini‚Äôs nano models have a very low TTFT.
> https://x.ai/news/grok-voice-agent-api
Today, we're excited to launch the Grok Voice Agent API, empowering developers to build voice agents that speak dozens of languages, call tools, and search realtime data.

The Grok Voice Agent API is built on the same stack that powers Grok Voice for millions in our mobile apps and Tesla vehicles, and we‚Äôre thrilled to open up this proven technology to all via the xAI API.

> @cartesia_ai
 TTS is pretty good

> Whisper, https://smallest.ai/
Voice AI Suite
for Enterprises
Voice Agents and Models for Real Time Communications

> STT-LLM-TTS pipe is faster then any native audio model.

Use LiveKit, groq, deepgram, and cartesia.

You can achieve sub 500ms latency.

1) Bot + Rate protections (technical)
Summary

This app defends the realtime LLM endpoint using layered protections:

Edge middleware ‚Äî first line of defense at the edge (Vercel Edge / Next middleware). Fast IP + user limiting using Upstash or a dev in-memory fallback. Drops abusive traffic before it hits the API handler or DB.
BotID (client + server) ‚Äî distinguishes automated clients vs human browsers. Client injects signals; server call (checkBotId()) evaluates them and can block suspicious bots.
Route-level rate limiter (withRateLimit) ‚Äî server-side per-minute counters persisted in Mongo. Applies fixed-window counters and per-session tokens/dollars / daily quotas. It also clears session cookie if needed.
Session creation guards ‚Äî concurrent-session caps (per-user), OTP authentication requirement (optional via .env toggle), and normalized tools validation.
In-session monitoring ‚Äî client/server report of usage to /api/auth/usage, heartbeat endpoint for idle/duration enforcement, and session docs in Mongo to end sessions mid-stream when budget/duration exceeded.

These layers work together to:

Drop cheap/large-volume abusive traffic at the edge.
Block scripted bots with BotID.
Prevent single users from opening many realtime sessions.
Track tokens and estimated dollars in near real time and terminate sessions when daily caps are hit.

Full flow (step-by-step)

0. Client behaviour (what the app does)

Client loads <BotIdClient protect={[{path:'/api/session',method:'POST'}]} /> (or initBotId) in app/layout.tsx. BotID client collects signals and ensures the /api/session POST includes BotID headers.
When starting a voice session the client POST /api/session with e.g. { model, voice, tools, instructions }. If OTP mode is enabled the request must include tenant_session cookie (set by OTP flow).

1. Edge Middleware (middleware.ts) ‚Äî first line

Matcher: /api/session (scoped).

What it enforces:

IP-based per-minute limiter (edge). Uses Upstash Ratelimit if configured; falls back to an in-memory per-minute counter in dev.
User-based per-minute limiter (edge) when the tenant_session cookie is present (uses email extracted from cookie).
If user limit is exceeded -> returns 429 and clears cookie (optional).
If IP limit is exceeded -> returns 429 (cookie may remain).

Why keep it: cheap rejects before route handler/DB work, lower latency for drops, prevents large distributed scans.

2. Route handler wrapper (withRateLimit) ‚Äî server-side second line

Called from app/api/session/route.ts (the route POST is wrapped with withRateLimit(req, handler, cfg)).

What it does:

Obtains IP and session info via getActiveOtpSession() if cookie present.
Uses a Mongo-backed fixed-window counter (stored in ratelimits collection) to increment ip & user counters for the current minute window (upsert).
Checks per-minute thresholds (configurable). On exceeding, returns 429 and clears cookie.
Checks per-day quotas by reading the auth doc for the otp_session (usage tokens/dollars). If daily usage exceeds USER_MAX_TOKENS_DAILY / USER_MAX_DOLLARS_DAILY, mark session ended in DB, clear cookie, return 429.
Why keep it: this is authoritative server state (Mongo) ‚Äî harder for an attacker to manipulate than client counters.

3. BotID server verdict (in createSession route)

Server call: const verdict = await checkBotId().
Decision: If verdict.isBot && !verdict.isVerifiedBot then reject 403. (You can tune policy to allow verified bots or blacklist certain bots.)

Why: prevents scripted automation that mimics browsers and bypasses simple checks.

4. OTP requirement (configurable)

Function used: getActiveOtpSession() (reads tenant_session cookie and looks up auth session in Mongo).
Policy toggle: set REQUIRE_AUTH_FOR_SESSION=true to force login before session creation.

If required: createSession rejects 401 if no active OTP session.

5. Concurrent session cap

Behavior: the realtime_sessions collection stores docs { _id: 's:${emailHash}:${opaqueId}', emailHash, startedAt, lastSeenAt, active }.
When creating a session, we countDocuments({ emailHash, active: true }) and reject with 429 if >= MAX_CONCURRENT_SESSIONS_PER_USER.
Why: stops one user from opening many simultaneous streams.

6. Upstream OpenAI realtime session creation

If checks pass, we call the OpenAI realtime sessions endpoint and return the upstream id plus our sm_session_id. We store a local session doc to enable heartbeats, idle checks, and mid-stream termination.

7. In-session usage reporting and enforcement

Client should report response.done usage events to /api/auth/usage with { tokens, dollars }. (Prefer server-side relay if tamper-proof needed.)
Server stores tokens/dollars in the auth doc (auth.usage.tokens, auth.usage.dollars) through app/api/auth/usage/route.ts.

Heartbeat endpoint: client pings /api/realtime/heartbeat periodically with { sm_session_id, email }. Server checks:
Session duration vs MAX_SESSION_MINUTES
Idle time vs MAX_SESSION_IDLE_SEC
Daily quota vs usage_daily doc

If any exceeded -> server sets realtime_sessions.active=false, clears cookie, returns 403 + reason -> client must close peer connection.

Why: allows mid-stream shutdown when a user keeps talking and hits budget or time limits.

Where token/dollar accounting originates

Best: use the Realtime API response.done events which include usage totals. Client forwards those to /api/auth/usage. Server increments auth.usage.
Reconciliation: optionally poll OpenAI Usage API periodically to reconcile for billing accuracy.

.env configuration (names, meanings, defaults)

Put these in .env ‚Äî the app reads them to tune behavior.

RATE_IP_PER_MIN ‚Äî integer. Max requests per IP per minute at the edge. Default: 60.
RATE_USER_PER_MIN ‚Äî integer. Max requests per user per minute at the edge. Default: 120.
USER_MAX_TOKENS_DAILY ‚Äî integer. Max tokens allowed per user per day before hard stop. Default: 150000.
USER_MAX_DOLLARS_DAILY ‚Äî number. Max estimated dollars allowed per user per day. Default: 15.
MAX_CONCURRENT_SESSIONS_PER_USER ‚Äî integer. Max live realtime sessions per user. Default: 2.
MAX_SESSION_MINUTES ‚Äî integer. Max duration per session (minutes). Default: 15.
MAX_SESSION_IDLE_SEC ‚Äî integer. Max idle time (seconds) allowed. Default: 90.

UPSTASH_REDIS_REST_URL and UPSTASH_REDIS_REST_TOKEN ‚Äî Upstash configuration for edge-limiter. If missing, middleware falls back to in-memory limiter (dev only).

REQUIRE_AUTH_FOR_SESSION ‚Äî true|false. If true, /api/session requires an active OTP session cookie. Default: false (makes demo public but protected by BotID & rate-limits).

JWT_SECRET, TRANSPORT_*, OPENAI_API_KEY, DB envs ‚Äî other envs used by routes.

How the system catches a protracted conversation (example timeline)

1. User opens session; client posts to /api/session:
2. Edge middleware checks IP & user minutely counters; allows or rejects.
3. Route-level withRateLimit increments Mongo counters and checks per-minute limits + daily quotas.
4. BotID server check validates client.
5. OTP check (if required) ensures identity.
6. Concurrent sessions check prevents many sessions.
6. Upstream session is created and local realtime_sessions doc added.
7. User interacts with the agent for many turns:
8. Client receives response.done events and posts usage (tokens/dollars) to /api/auth/usage. Server increments auth.usage.
9. Heartbeats from client update realtime_sessions.lastSeenAt.
10. When the user reaches daily tokens/dollars OR session duration/idle thresholds:
-- enforceDailyQuota() or heartbeat checks detect overage.
-- Server marks realtime_sessions.active=false, updates auth to status: 'ended', clears cookie, returns error to client.
-- Client receives error / close signal and closes the peer connection.

Because usage is tracked during the session and both minute- and daily-level quotas are enforced, a long protracted conversation will be caught either at the moment the /api/auth/usage increment pushes the auth doc beyond daily thresholds, or when heartbeat detects duration/idle violation.

---------------------------------------------------
Storage model & what those Mongo docs mean

### Collections

* **`ratelimits`** (per-minute counters; fixed window)

  * `_id`: `"<scope>:<key>:<winId>"` where

    * `scope` ‚àà {`ip`, `user`, `sess`}
    * `key`   = IP string, `sha256(email)`, or `sessionTokenHash`
    * `winId` = `floor(epochSeconds / windowSec)` ‚Äî a rolling integer that identifies the current fixed window
  * `count`: how many requests within this (scope, key, window) so far
  * `windowSec`: the size of the fixed window (defaults `60`)
  * `createdAt`: when this window doc was first created

  **Example you saw:**

  ```json
  {"_id":"ip:127.0.0.1:29367014","count":1,"createdAt":"2025-...","windowSec":60}
  ```

  This means: for IP `127.0.0.1` in the window whose id is `29367014` (which corresponds to a specific 60s slice), 1 call has been counted.

* **`realtime_sessions`** (active session registry)

  * `_id`: `"s:<sha256(email)>:<opaqueSessionId>"`
  * `emailHash`: `sha256(email)` to avoid storing raw email in this collection
  * `startedAt`: when we created the upstream Realtime session
  * `lastSeenAt`: last heartbeat/interaction (update this via your socket/WS ping or an HTTP heartbeat)
  * `active`: boolean flag; set to `false` on orderly close, or by janitor when idle or over max duration

  **Example you saw:**

  ```json
  {
    "_id": "s:dca6...7621:sess_CXAlw...",
    "active": true,
    "emailHash": "dca6...7621",
    "lastSeenAt": "2025-...",
    "startedAt": "2025-..."
  }
  ```

  This means: a live session for that user hash started at `startedAt`, was last active at `lastSeenAt`, and is currently `active: true`.

* **`usage_daily`** (per-user daily quotas)

  * `_id`: `"d:<sha256(email)>:<YYYY-MM-DD>"`
  * `tokens`, `dollars`: running totals for that day
  * Updated by your usage accounting hook after each completion/stream chunk.

### Upstash Redis (edge)

* We use Upstash‚Äôs **sliding window** limiter. 
Keys are ephemeral and managed by Upstash; you may not see persistent keys in the dashboard. 
With `analytics: true`, Upstash records aggregated stats you can inspect. 
If you prefer visible counters, mirror increments into Mongo for debugging (behind a `DEBUG_METRICS` flag) ‚Äî not recommended for prod.

-------------------
Troubleshooting tips:

- If you see many 404/botid script errors: verify next.config.ts uses withBotId, client <BotIdClient /> is in layout, and you restarted dev server.
- If middleware returns 429 prematurely: check Upstash quotas & keys or change RATE_IP_PER_MIN/RATE_USER_PER_MIN.
- To debug per-user counters: inspect ratelimits (Mongo) and realtime_sessions collections.

For reconciliation of dollars: periodically poll OpenAI Usage API and reconcile with your auth.usage store.

### Limits at a glance

| Category                         | What it controls                                                   | Default (env)                          | Where enforced           | What happens when exceeded                                                               |
| -------------------------------- | ------------------------------------------------------------------ | -------------------------------------- | ------------------------ | ---------------------------------------------------------------------------------------- |
| **Requests per IP**              | Max `/api/session` calls per minute from the same IP               | `RATE_IP_PER_MIN = 60`                 | **Edge (Upstash)**       | HTTP `429 Too Many Requests`. `Retry-After` header tells client when to retry.           |
| **Requests per user**            | Max `/api/session` calls per minute by the same authenticated user | `RATE_USER_PER_MIN = 120`              | **Edge (Upstash)**       | HTTP `429`. If authenticated, we may clear the session cookie to stop automated retries. |
| **Requests per session**         | Max API calls per minute within a single live session              | `RATE_SESSION_PER_MIN = 6`             | **Server (Mongo)**       | HTTP `429`. The client should slow down microphone/turn cadence.                         |
| **Daily tokens per user**        | Max LLM tokens the user can spend per day                          | `USER_MAX_TOKENS_DAILY = 150000`       | **Server (Mongo)**       | HTTP `429` once over the cap; session may be ended.                                      |
| **Daily dollars per user**       | Max dollars the user can spend per day                             | `USER_MAX_DOLLARS_DAILY = 5`           | **Server (Mongo)**       | HTTP `429`. Prevents surprise bills.                                                     |
| **Concurrent sessions per user** | How many live realtime sessions a user may run at once             | `MAX_CONCURRENT_SESSIONS_PER_USER = 2` | **Server (Mongo)**       | HTTP `429 Too many active sessions`.                                                     |
| **Max session length**           | Hard cap on single session duration                                | `MAX_SESSION_MINUTES = 15`             | **Server janitor/close** | Session is closed when it hits the cap.                                                  |
| **Idle timeout**                 | Auto-closes sessions with no activity                              | `MAX_SESSION_IDLE_SEC = 300`           | **Server janitor/close** | Session is marked inactive and upstream socket is closed.                                |

### How to tune safely

* Start conservative (lower `USER_MAX_DOLLARS_DAILY`) and raise for trusted tenants.
* Prefer *per-session* minute limits to keep audio turn cadence reasonable.
* Keep edge limits ‚â• server limits to avoid edge flapping.
* Monitor: look at `X-RateLimit-*` headers and Upstash analytics; alert on 429 spikes.

---

## 9) Operational examples

* **Decode a `ratelimits._id`** like `ip:203.0.113.5:29367014` with `windowSec=60`:

  * `winStart = new Date((29367014 * 60) * 1000)` ‚Üí the exact 60s slice start.
* **Find users who hit the cap** in the last 10 minutes:

  ```js
  const since = new Date(Date.now() - 10*60*1000);
  db.ratelimits.aggregate([
    { $match: { createdAt: { $gte: since }, _id: { $regex: /^user:/ } } },
    { $group: { _id: "$_id", maxCount: { $max: "$count" } } },
    { $match: { maxCount: { $gt: Number(process.env.RATE_USER_PER_MIN || 120) } } }
  ])
  ```

---

heartbeat doc

Heartbeat is a lightweight POST the client sends every ~45 seconds while a realtime session is connected. It serves three purposes:

Liveness tracking ‚Äî updates realtime_sessions.lastSeenAt so the server knows the session is active.

Auto-cleanup ‚Äî a background janitor safely closes sessions that have:

been idle longer than MAX_SESSION_IDLE_SEC, or

exceeded MAX_SESSION_MINUTES.
Heartbeats ensure legit sessions aren‚Äôt mistaken for idle.

Concurrency enforcement ‚Äî accurate liveness lets us enforce MAX_CONCURRENT_SESSIONS_PER_USER and stop ‚Äúghost‚Äù sessions from consuming slots/cost.

If the browser/tab dies or the network drops, heartbeats stop, and the janitor will mark the session inactive on the next sweep.
------------------

View the 2 stripe webhooks Here

https://dashboard.stripe.com/acct_1C7jlWHPEZeOT4G4/workbench/webhooks

Note each webhook has a distinct webhook secret ... so are set differently on vercel vs local dev

The webhooks need to be enabled in TEST mode ... switch to test then select developer > webhooks to see the defined webhooks and their keys

------------------
All rate checks and session limits and bot checks throw errors with a uniform signature ...
return NextResponse.json(
  { error: "Bot verification failed", 
    code: "BOT_BLOCKED",
    userMessage: "We couldn‚Äôt verify this device. Please refresh and try again." },
  { status: 403 }
);

To locate these security and stress points through the code base simly search on that json structure

----------
## 10) Optional: visibility mirror for Upstash (debug)

If you *really* want to see edge counters in Mongo during dev, add a `DEBUG_METRICS=true` env and in `middleware.ts` write a tiny doc `{_id: 'edge:<key>:<winId>', count,...}` to `ratelimits`. Keep this *off* in production to avoid write amplification.

</StepCard>

  1. **Build/Examine APIs**: Ensure endpoints match your tool descriptors. Use secure auth (e.g., Bearer tokens via secrets).

  2. **Data Object Structure**: Responses should be detailed but concise. Example for a hotel room (adapt for products/recipes/events):
     ```json
     {
       "name": "Ridge Villa",
       "unitNumber": "1",
       "type": "villa",
       "description": "Magnificent stream view with hot tub and sauna.",
       "rate": 685,
       "currency": "USD",
       "config": {
         "squareFeet": 825,
         "beds": [{ "size": "king", "count": 1 }],
         "amenities": { "wellness": ["hot tub", "sauna"] }
       },
       "images": [
         { "url": "https://example.com/image.jpg", "role": "gallery" }
       ],
       "policies": { "checkInTime": "15:00", "cancellation": { /* details */ } }
     }
     ```

     - For a product catalog: Include price, stock, images, reviews.
     - For recipes: Ingredients, steps, variations.

  3. **Test API Calls**: Use the JSON Editor to mock requests, or start the agent and query it to trigger tools.

  **Tip**: If data is in MongoDB, use gateway tools for direct queries. For web scraping, leverage core `scrapeWebsite`.


<StepCard title="Craft the System Prompt" description="The prompt activates the agent, sets its personality, and guides tool usage/dialog flow.">
  The prompt is a JSON object defining behavior, tool rules, and examples.
</StepCard>
  1. **Open the Prompt Editor**: Use the JSON Editor tool to create `agent-prompt.json`.

  2. **Structure**:
     ```json
     {
       "agent": {
         "tenantId": "your-business-id",
         "name": "Your Agent Name",
         "tone": "warm, concise, professional",
         "style_rules": [ /* Array of rules, e.g., "Always confirm details." */ ]
       },
       "capabilities": {
         "tools": {
           "your_custom_tool": {
             "when": [ /* Triggers, e.g., "User asks for availability." */ ],
             "args": [ /* Required params */ ],
             "success_say": "How to summarize results.",
             "handle_errors": { /* Error codes and responses */ }
           },
           // Include core tools as needed
           "scrapeWebsite": { /* ... */ }
         }
       },
       "policy": { /* Data rules, e.g., "Always check availability first." */ },
       "dialog_flow": { /* High-level steps */ },
       "schema_violation": [ /* Retry rules */ ],
       "response_templates": { /* Pre-formatted responses */ },
       "examples": [ /* User-agent interaction samples */ ]
     }
     ```

  3. **Example** (Adapted from Cypress for a product sales agent):
     ```json
     {
       "agent": {
         "name": "Product Guru",
         "tone": "helpful, enthusiastic",
         "style_rules": ["Never invent stock levels‚Äîcall tools."]
       },
       "capabilities": {
         "tools": {
           "search_products": {
             "when": ["User asks about products or searches."],
             "args": ["query"],
             "success_say": "List top matches with prices and descriptions."
           },
           "show_component": {
             "when": ["Display product images."],
             "args": ["component_name", "media"]
           }
         }
       },
       "dialog_flow": {
         "high_level": ["Search products, show visuals, guide to purchase."]
       }
     }
     ```

  4. **Save and Activate**: Use MongoDB Updater to store under tenantId. Restart the agent to apply.

  **Tip**: Use examples to train flows, e.g., for a chef agent: Banter on ingredients by calling a recipe search tool.

<StepCard title="Test and Iterate" description="Verify the agent's accuracy, tool usage, and responses.">
  Focus on validating real-world questions and whether the agent calls tools with correct arguments and handles failures gracefully.
</StepCard>

### Test steps

1. **Start the Agent**: Launch via the platform dashboard or command line.
2. **Run Tests**:
   - Voice queries: ‚ÄúBook a room for Jan 15‚Äì18‚Äù (or your use case).
   - Check logs for tool calls and responses.
   - Use test scripts if available, or simulate via direct interaction.
3. **Debug**:
   - If tools fail: Check schemas and APIs.
   - Refine prompt for better flow.
   - Expand visuals registry as needed (platform will update based on demand).

**Tip**: Assume good intent; the agent handles edgy queries factually. Expand core tools/visuals via feedback.

---

### Data Model (abridged)

#### Tool Descriptor Model
Overview of the fields commonly used when defining a tool descriptor.

- `name`: Unique identifier  
- `parameters`: JSON Schema for args  
- `http`: Config for API call  
- `ui`: Auto-render visuals on outcomes  

#### Prompt Model
The structure that sets personality, constraints, and how tools should be chosen.

- `agent`: Personality and rules  
- `capabilities.tools`: Per-tool guidelines  
- `dialog_flow`: Conversation structure  

#### Data Object Model
The flexible JSON returned by your APIs that the agent uses for grounding.

- Flexible JSON from your APIs (e.g., products with name, price, images)  
- Used for grounding responses


//////////////////rate limit management/////////////
Short answer: these limits are **safe and workable for a pilot hotel widget**, but I‚Äôd loosen a couple of them for a real busy resort and rely on your existing abuse controls to protect you.

Let‚Äôs go through them one by one in plain English.

---

## 1. Edge firewalls

```bash
RATE_IP_PER_MIN=60
RATE_USER_PER_MIN=120   # console only
RATE_BURST=20
```

### For the widget:

* `RATE_USER_PER_MIN` doesn‚Äôt matter ‚Äì widget calls don‚Äôt use the console JWT cookie.
* `RATE_IP_PER_MIN=60` means: from one IP, you‚Äôll allow **60 hits to `/api/session` per minute**.

If `/api/session` is **only used to create the realtime session**, then:

* 60 session-creates per minute per IP = 1 new call per second from a single IP.
* That‚Äôs already *very* liberal for a hotel website. It‚Äôs extremely unlikely they‚Äôll hit that with legitimate traffic.

**Caveat:** if in the future you start using `/api/session` for more frequent operations (not just session creation), you might want to bump this to something like `120` or `180`. But for ‚Äúone POST per call start‚Äù, `60` is fine.

---

## 2. Widget limits (the important ones)

```bash
WIDGET_SESSION_PER_MIN=12
WIDGET_MAX_TOKENS_DAILY=300000
WIDGET_MAX_DOLLARS_DAILY=20
WIDGET_MAX_CONCURRENT_SESSIONS=10
```

### WIDGET_SESSION_PER_MIN=12

This is effectively: **per tenant**, you‚Äôll allow 12 session creations per minute.

* That‚Äôs 1 new voice call every ~5 seconds.
* For a hotel/resort, that‚Äôs *already pretty generous*.
* If traffic grows to ‚Äúcrazy busy‚Äù, you can bump this to e.g. `30`, but 12 is not going to clip normal behavior.

üëâ I‚Äôd keep `12` to start. It‚Äôs a good ‚Äúare we under attack or not?‚Äù threshold.

---

### WIDGET_MAX_CONCURRENT_SESSIONS=10

This is the **biggest lever** for a hotel.

* 10 concurrent voice sessions = at most 10 guests talking to the agent at exactly the same time.

Is that enough?

* For a **small/mid-size hotel** or early-stage rollout: probably yes.
* For a **big resort with lots of web traffic** and strong marketing push: 10 might be tight at peak hours.

**My suggestion:**

* For your *first* commercial installs: set this to **20** instead of 10:

  ```bash
  WIDGET_MAX_CONCURRENT_SESSIONS=20
  ```
* Then log/monitor:

  * Peak concurrent sessions
  * How often you hit that limit

If you want to start even more conservatively, keep 10 for ‚Äúfree/trial‚Äù plans and 20+ for paying customers.

---

### WIDGET_MAX_TOKENS_DAILY=300000

This is your cost fuse. Rough mental math:

* Let‚Äôs say one typical booking conversation is ~5 minutes of back-and-forth.
* That might be ~800‚Äì1500 tokens total (hugely approximate, but good enough).

At 1000 tokens per conversation average, `300,000` tokens/day = **~300 conversations per day**.

For a single hotel:

* 300 conv/day is **a lot** for most properties.
* If they‚Äôre bigger / chain-level / heavy marketing, they *could* hit that.

You already also have:

```bash
WIDGET_MAX_DOLLARS_DAILY=20
```

So you effectively have **two brakes**, and the *tighter* one wins.

If you want the hotel widget to feel ‚Äúalways on‚Äù and let the **$ limit be your real safety valve**, you could:

* Raise tokens and keep dollars as the primary fuse:

  ```bash
  WIDGET_MAX_TOKENS_DAILY=1000000   # ~1M tokens/day
  WIDGET_MAX_DOLLARS_DAILY=20       # daily hard cap
  ```

That way:

* Under normal usage, they‚Äôll never hit the token limit.
* If something goes off the rails (scripted attacker, runaway integration), the **$20/day** cap kicks in first and stops the bleeding.

If you‚Äôre more conservative on cost, your current `300k` is okay; just know it‚Äôs ‚Äúfew hundred conversations / day‚Äù territory.

---

## 3. Session lifetime

```bash
MAX_SESSION_MINUTES=15
MAX_SESSION_IDLE_SEC=300
```

For a hotel reservation agent:

* 15 minutes per session is **more than enough** for even a messy booking.
* 5 minutes idle timeout is also fine ‚Äì user walks away, closes tab, etc.

These are totally reasonable.

---

## 4. Console limits look good

```bash
CONSOLE_SESSION_PER_MIN=3
CONSOLE_MAX_TOKENS_DAILY=50000
CONSOLE_MAX_DOLLARS_DAILY=1
CONSOLE_MAX_CONCURRENT_SESSIONS=1
```

Perfect for:

* ‚ÄúLet people demo it, but if someone tries to hammer it, shut it down fast.‚Äù
* One concurrent session per console user is exactly what you want for a personal demo.

No changes needed there.

---

## 5. Overall: are these realistic for a hotel widget?

**Yes**, with two tweaks I‚Äôd strongly recommend:

1. **Increase concurrency for widget:**

   ```bash
   WIDGET_MAX_CONCURRENT_SESSIONS=20
   ```

   so a busy resort doesn‚Äôt get ‚Äúagent busy‚Äù at the first little spike.

2. **Consider loosening the token cap and letting the $ cap be the real fuse:**

   ```bash
   WIDGET_MAX_TOKENS_DAILY=1000000
   WIDGET_MAX_DOLLARS_DAILY=20
   ```

   ‚Äì or keep `300000` tokens for now, but know you might increase it once you see real usage.

With:

* per-IP 60 req/min,
* per-tenant session-per-minute limit,
* per-tenant concurrency limit,
* per-tenant daily tokens and dollars,

you‚Äôre in a good place: **hotel widget feels always-available for normal traffic, but a single bad actor or script can only do limited damage before tripping a fuse.**


For widgets, the right mental model is:

Tenant should feel ‚Äúunlimited‚Äù

‚Ä¶but you still enforce fairness + safety at three levels:

A) Per-session limits (hard safety)

You already have these:

maxSessionMinutes

maxSessionIdleSec
These are your best ‚Äúabuse-proof‚Äù controls because real users don‚Äôt talk for 2 hours nonstop.

‚úÖ Keep these.

B) Per-tenant concurrency (business safety)

A hotel doesn‚Äôt need 200 concurrent calls from one page unless something is wrong.
You already show:

active / maxConcurrent per tenant

‚úÖ This is the best non-disruptive limiter: it protects cost without affecting typical customers.

C) Per-visitor ‚Äúbehavioral‚Äù detection (abuse safety) ‚Äî not blunt rate limiting

Instead of ‚Äúrequests/min‚Äù, detect patterns like:

very long sessions repeatedly

repeated sessions from same IP/device across many tenants

repeated ‚Äústart session‚Äù without meaningful usage

extremely high token burn vs typical for that agent (your ‚Äúpredictable use case‚Äù point)

What action do you take when detected?

Use ‚Äústep-up friction‚Äù, not a hard block:

require OTP for that visitor

require captcha on session start

temporarily shorten maxSessionMinutes for that visitor/IP

temporarily reduce concurrent sessions for that tenant+ip

This keeps normal bookings unaffected while shutting down a bot.
=================
What you can detect today without invasive tracking

IP address

User-Agent (UA)

TenantId (from widget JWT sub)

Widget key (claims.key)

Time-based patterns (sessions started per IP per tenant, etc.)

Optional: a lightweight anonymous visitor id stored in localStorage cookie

A minimal implementation plan (Mongo-backed, fixed window)

Create a new collection: abuse_signals (TTL indexed).

Each doc represents a counter in a time window, similar to your ratelimits approach:

tenant:<tenantId>:ip:<ip>:<winId> ‚Üí session starts per minute

ip:<ip>:<winId> ‚Üí session starts per minute across all tenants

tenant:<tenantId>:ip:<ip>:day:<YYYY-MM-DD> ‚Üí starts per day

tenant:<tenantId>:ip:<ip>:overdur:<YYYY-MM-DD> ‚Üí ‚Äúover-duration sessions‚Äù count (if you want)

Then at /api/session creation time:

increment these counters

compute a risk score

if risk high ‚Üí respond with 403 and code: "STEP_UP_REQUIRED" plus a stepUp: { kind: "captcha" | "otp" }


=====================more work on session state ==============
A practical, consistent definition of session states
Field meanings (keep exactly as-is)

Age = now - startedAt

Idle = now - lastSeenAt

Session ‚Äúliveness‚Äù states (what the dashboard should show)

We should separate ‚Äútracking flag‚Äù from ‚Äúliveness.‚Äù

1) Live (Engaged)

active:true

idleSec <= maxSessionIdleSec

2) Live (Idle/Open)

active:true

idleSec > maxSessionIdleSec

idleSec <= staleGraceSec (ex: 1 hour or 24 hours ‚Äî your choice)

3) Stale (Abandoned)

active:true

idleSec > staleGraceSec OR ageSec > hardMaxAgeSec
These are not truly active; they are stale docs that should have been closed.

4) Ended

active:false (admin ended or auto-ended)

optionally show endedAt/reason in an ‚ÄúEnded sessions‚Äù view

Right now you only show 1‚Äì3, but your dataset contains a ton of #3.

1) Who is being measured by idleSec / staleGraceSec?

That ‚Äúdigit‚Äù (idle seconds / age seconds) is per session record, i.e. per visitor conversation session (a single Realtime session identified by smSessionId), not the tenant itself.

Tenant (website owner) = tenantId on the session doc (e.g. cypress-resorts)

Visitor (end user on that site) = each realtime_sessions document (one per WebRTC/OpenAI realtime session)

idleSec = ‚Äúhow long since that visitor‚Äôs session sent heartbeat‚Äù

staleGraceSec = ‚Äúafter how long without heartbeat do we consider that visitor session abandoned/stale‚Äù

So: stale applies to visitor sessions, then you aggregate those sessions by tenant to compute tenant-level counts (engaged/idle/stale).

=================
Going to AGENTS_ID.md ... strategy and risks 
Big pros

Tenant-owned content
Tenants can iterate on agents, PR their changes, review history, branch, etc. That‚Äôs exactly what Git is good at.

Human-friendly editing
Markdown + some structured conventions is much more approachable for non-devs than JSON with 200 lines of nested arrays/objects.

Environment separation & versioning
You can point staging to staging branch, prod to main, etc. Rollback is just git revert.

Your platform becomes pure runtime + tooling
Prompts, persona, policies, etc. are just inputs. You can later support other backends (not only GitHub) with the same parser.

Security / multi-tenant isolation
Each tenant‚Äôs agent spec only affects that tenant. ‚ÄúJailbreaks‚Äù in their prompts only hurt their own bot, which is exactly what they‚Äôre paying you to control.

Things to watch out for

Runtime fragility
If you fetch from GitHub on every connect, you‚Äôre now dependent on GitHub latency and outages.
‚Üí Fix: cache the parsed result per tenantId + agentId (e.g., in Redis or your own DB) and refresh on a timer or when webhook says ‚Äúnew commit‚Äù.

Validation
A tenant can easily break the file (missing YAML, typo in heading, etc.).
‚Üí Fix: validate after parsing and:

either fail fast with a clear error

or fallback to a safe default agent (like your "unknown" agent) and log the error.

Security
You‚Äôll probably want to restrict which repos/branches are allowed, and make sure you only fetch from whitelisted hosts.

Given those caveats, I‚Äôd absolutely go this route. The key is: treat AGENT_ID.md as a source artifact, but cache + validate before it ever reaches Realtime.


=========================

TENANT OBJECT - NOTICE in the widgetKeys

> this object is used by voice-machine to control access to voice agents
> the key must be loaded by the tenant in their script on their site
> and the origin must match exactly the url of their site

otherwise an attempt to load the voice agent widget to the tenant site will be
rejected as unauthorized or CORS error

{
  _id: {
    $oid: "6939cb803ac721430154baba"
  },
  tenantId: "cypress-resorts",
  name: "Cypress Resorts",
  status: "trial",
  identity: {
    legalName: "Cypress Resorts Inc",
    displayName: "Cypress Resorts",
    domain: "cypressresort.com",
    industry: "hospitality",
    timeZone: "America/Atlanta",
    locale: "en-US"
  },
  contacts: {
    primary: {
      name: "Tanner Cummings",
      email: "tanner@cypressresort.com",
      phone: "+1-540-383-8282",
      role: "Founder"
    },
    billing: {
      name: "Finance",
      email: "finance@cypressresort.com"
    },
    technical: {
      name: "CTO",
      email: "cto@cypressresort.com"
    }
  },
  billing: {
    provider: "Stripe",
    customerId: "cypress-resort",
    defaultPaymentMethodId: "cypress_master_1111",
    currency: "USD",
    billingEmail: "finance@cypressresort.com",
    billingAddress: {
      line1: "1773 Hwy 53 East",
      line2: "",
      city: "Jasper",
      state: "GA",
      postalCode: "30143",
      country: "USA"
    },
    plan: {
      planId: "voice-starter",
      name: "Voice Agent Starter",
      interval: "month",
      seatLimit: {
        $numberInt: "3"
      },
      agentLimit: {
        $numberInt: "5"
      },
      trialEndsAt: {
        $date: {
          $numberLong: "1768435200000"
        }
      }
    },
    cardSnapshot: {
      brand: "mastercard",
      last4: "1111",
      expMonth: {
        $numberInt: "5"
      },
      expYear: {
        $numberInt: "2028"
      }
    },
    status: "trialing",
    nextBillingDate: {
      $date: {
        $numberLong: "1768521600000"
      }
    }
  },
  agentSettings: [
    {
      agentId: "concierge",
      label: "Cypress Concierge",
      agentRepo: {
        provider: "github",
        baseRawUrl: "https://raw.githubusercontent.com/pdhoward/documentation/main/AGENT_CYPRESSRESORTS.md"
      }
    }
  ],
  limits: {
    maxAgents: {
      $numberInt: "5"
    },
    maxConcurrentCalls: {
      $numberInt: "15"
    },
    maxMonthlyMinutes: {
      $numberInt: "2000"
    },
    maxRequestsPerMinute: {
      $numberInt: "60"
    }
  },
  flags: {
    betaFeatures: false,
    allowExternalBrandInfo: true,
    allowExperimentalModels: false
  },
  widgetKeys: [
    {
      id: "cypress-resorts",
      key: "w_cypress_main_7f1b0e9c64f54d1a",
      origin: "https://cypressresort.vercel.app",
      label: "Main marketing site",
      revoked: false
    }
  ],
  createdAt: {
    $date: {
      $numberLong: "1762819200000"
    }
  },
  updatedAt: {
    $date: {
      $numberLong: "1762992000000"
    }
  }
}

